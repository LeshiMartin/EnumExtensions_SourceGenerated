using System.Collections.Immutable;
using System.Diagnostics;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace EnumExtensionsGenerator;

/// <summary>
/// Attribute specifying that extensions should be generated for the enum
/// </summary>
public class EnumExtensions : Attribute;

/// <summary>
/// Attribute specifying the desired <paramref name="Name"/> for the Enum member
/// </summary>
/// <param name="Name">The desired name</param>
#pragma warning disable CS9113 // Parameter is unread.
public class EnumName(string Name) : Attribute;

/// <summary>
/// Attributes specifying the desired <paramref name="Description"/> for the Enum member
/// </summary>
/// <param name="Description"></param>
public class EnumDescription(string Description) : Attribute;
#pragma warning restore CS9113 // Parameter is unread.

[Generator]
public class EnumExtensionsGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider.CreateSyntaxProvider(
            (node, _) => node is EnumDeclarationSyntax @enum && @enum.HasAttribute(nameof(EnumExtensions)),
            (node, _) => (EnumDeclarationSyntax)node.Node
        ).Where(x => x is not null);

        var compilation = context.CompilationProvider.Combine(provider.Collect());
        context.RegisterSourceOutput(compilation, Execute!);
    }

    private void Execute(SourceProductionContext context,
        (Compilation Left, ImmutableArray<EnumDeclarationSyntax> Right) arg2)
    {
        // if (!Debugger.IsAttached)
        // {
        //     Debugger.Launch();
        // }
        var (s, enums) = arg2;
        if (enums.IsEmpty) return;
        var sb = new StringBuilder().AppendLine("// <auto-generated/>\n");
        var @namespace = $"namespace {s.AssemblyName};";
        var usings = new HashSet<string>();
        var classSb = new StringBuilder()
            .AppendLine("""
                        public static class GeneratedEnumExtensions
                        {
                        """);

        foreach (var @enum in enums)
        {
            usings.Add("using " + @enum.Parent!.GetNamespaceName(s.AssemblyName!) + ";");
            classSb
                .AppendLine(@enum.GetNameMethod())
                .AppendLine(@enum.GetDescriptionMethod());

            if (@enum.HasAttribute("Flags"))
            {
                classSb.AppendLine(GenerateAddFlag(@enum))
                    .AppendLine(GenerateRemoveFlag(@enum))
                    .AppendLine(GenerateContainsFlag(@enum));
            }
        }

        classSb.AppendLine("}");
        sb.AppendLine(string.Join("\n", usings))
            .AppendLine(@namespace)
            .AppendLine(classSb.ToString());

        var final = sb.ToString();

        context.AddSource("EnumExtensionsGeneratorGenerated.g.cs", final);
    }

    private string GenerateAddFlag(EnumDeclarationSyntax enumDeclarationSyntax)
    {
        var enumName = enumDeclarationSyntax.Identifier.ToString();
        return $$"""
                 /// <summary>
                 /// It will add the <paramref name="other"/> flag to the <paramref name="source"/> 
                 /// </summary>
                 /// <param name="source">The enum on which the flag will be added</param>
                 /// <param name="other">The other flag value</param>
                 /// <returns>{{enumName}} with the added <paramref name="other" /> </returns>
                 public static {{enumName}} AddFlag(this {{enumName}} source, {{enumName}} other)
                 {
                    source |= other;
                    return source;
                 }
                 """;
    }


    private string GenerateRemoveFlag(EnumDeclarationSyntax enumDeclarationSyntax)
    {
        var enumName = enumDeclarationSyntax.Identifier.ToString();
        return $$"""
                 /// <summary>
                 /// It will remove the <paramref name="other"/> flag from the <paramref name="source"/> 
                 /// </summary>
                 /// <param name="source">The enum from which the flag will be removed</param>
                 /// <param name="other">The other flag value</param>
                 /// <returns>{{enumName}} with the removed <paramref name="other" /> </returns>
                 public static {{enumName}} RemoveFlag(this {{enumName}} source, {{enumName}} other)
                 {
                    source &= ~other;
                    return source;
                 }
                 """;
    }


    private string GenerateContainsFlag(EnumDeclarationSyntax enumDeclarationSyntax)
    {
        var enumName = enumDeclarationSyntax.Identifier.ToString();
        return $"""
                /// <summary>
                /// It will check if the <paramref name="other"/> contains <paramref name="source"/> 
                /// </summary>
                /// <param name="source">The enum which will be checked</param>
                /// <param name="other">The other flag value</param>
                /// <returns>
                /// <c>true</c> if <paramref name="source"/>  contains <paramref name="other"/> otherwise <c>false</c>
                /// </returns>
                public static bool ContainsFlag(this {enumName} source, {enumName} other)
                   => (source & other) != 0;
                """;
    }
}