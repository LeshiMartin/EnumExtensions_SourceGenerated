using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace EnumExtensionsGenerator;

/// <summary>
///     Attribute specifying that extensions should be generated for the enum
/// </summary>
public class EnumExtensions : Attribute;

/// <summary>
///     Attribute specifying the desired <paramref name="Name" /> for the Enum member
/// </summary>
/// <param name="Name">The desired name</param>
#pragma warning disable CS9113 // Parameter is unread.
public class EnumName(string Name) : Attribute;

/// <summary>
///     Attributes specifying the desired <paramref name="Description" /> for the Enum member
/// </summary>
/// <param name="Description"></param>
public class EnumDescription(string Description) : Attribute;
#pragma warning restore CS9113 // Parameter is unread.

[Generator]
public class EnumExtensionsGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider.CreateSyntaxProvider(
                (node, _) => node is EnumDeclarationSyntax @enum && @enum.HasAttribute(nameof(EnumExtensions)),
                (node, _) => (EnumDeclarationSyntax)node.Node
            )
            .Where(x => x is not null);

        var compilation = context.CompilationProvider.Combine(provider.Collect());
        context.RegisterSourceOutput(compilation, Execute!);
    }

    private void Execute(SourceProductionContext context,
        (Compilation Left, ImmutableArray<EnumDeclarationSyntax> Right) arg2)
    {
        // if (!Debugger.IsAttached)
        // {
        //     Debugger.Launch();
        // }

        var (s, enums) = arg2;
        if (enums.IsEmpty) return;
        var sb = new StringBuilder().AppendLine("// <auto-generated/>\n");
        var @namespace = $"namespace {s.AssemblyName};";
        var usings = new HashSet<string>();
        var extensionsClassSb = GetExtensionsClassSb();
        var helpers = new StringBuilder();

        foreach (var @enum in enums)
        {
            var helperClassSb = GetHelperClassSb(@enum);
            usings.Add("using " + @enum.Parent!.GetNamespaceName(s.AssemblyName!) + ";");
            extensionsClassSb
                .AppendLine(@enum.GetNameMethod())
                .AppendLine(@enum.GetDescriptionMethod());


            helperClassSb
                .AppendLine(GenerateGetValues(@enum))
                .AppendLine(GenerateGetNames(@enum))
                .AppendLine(GenerateConvertFromName(@enum))
                .AppendLine(GenerateGetMaxValue(@enum, s))
                .AppendLine(GenerateGetMinValue(@enum, s))
                .AppendLine(GenerateConvertFromValue(@enum, s));

            if (@enum.HasAttribute("Flags"))
                extensionsClassSb.AppendLine(GenerateAddFlag(@enum))
                    .AppendLine(GenerateRemoveFlag(@enum))
                    .AppendLine(GenerateContainsFlag(@enum));

            helpers.AppendLine(helperClassSb.AppendLine("}").ToString());
        }

        extensionsClassSb.AppendLine("}");
        sb.AppendLine(string.Join("\n", usings))
            .AppendLine(@namespace)
            .AppendLine(extensionsClassSb.ToString())
            .AppendLine(helpers.ToString());

        var final = sb.ToString();

        context.AddSource("EnumExtensionsGeneratorGenerated.g.cs", final);
    }

    private static StringBuilder GetHelperClassSb(EnumDeclarationSyntax @enum)
    {
        var helperClassSb = new StringBuilder().AppendLine(
            $$"""
              /// <summary>
              /// Class containing helper methods for <see cref="{{@enum.Identifier.ValueText}}"/>
              /// </summary>
              public static class {{@enum.Identifier.ValueText}}Helper
              {
              """);
        return helperClassSb;
    }

    private static StringBuilder GetExtensionsClassSb()
    {
        var extensionsClassSb = new StringBuilder()
            .AppendLine("""
                        public static class GeneratedEnumExtensions
                        {
                        """);
        return extensionsClassSb;
    }


    private string GenerateGetValues(EnumDeclarationSyntax @enum)
    {
        var enumName = @enum.Identifier.ToString();
        var start = $$"""
                          /// <summary>
                          /// It will return an IReadOnlyCollection from the values from {{enumName}}
                          /// </summary>
                          /// <returns> <see cref="IReadOnlyCollection{T}"/> </returns>
                          public static IReadOnlyCollection<{{enumName}}> GetValues()
                           =>
                      """;

        var arr = @enum.Members
            .Select(x => $"{enumName}.{x.Identifier.ValueText}")
            .Aggregate(" new [] {", (x, y) => x + $"{y},");
        var modified = arr.Substring(0, arr.Length - 1) + "};\n";
        return start + modified;
    }

    private static string GenerateGetNames(EnumDeclarationSyntax @enum)
    {
        var enumName = @enum.Identifier.ToString();
        var start = $$"""
                          /// <summary>
                          /// It will return an IReadOnlyCollection from the names from {{enumName}}
                          /// </summary>
                          /// <param name="respectAttribute"> if <c>true</c> than it will return the values with the desired attribute name </param>
                          /// <remarks> It will call <see cref="GeneratedEnumExtensions.GetName" /> for each Member </remarks>
                          /// <returns> <see cref="IReadOnlyCollection{T}"/> </returns>
                          public static IReadOnlyCollection<string> GetNames(bool respectAttribute = false)
                           =>
                      """;

        var arr = @enum.Members
            .Select(x => x.GetDesiredMemberName(x.Identifier.ValueText))
            .Aggregate(" new [] {", (x, y) => x + $"\"{y}\",");
        var originalNames = @enum.Members.Select(x => x.Identifier.ValueText)
            .Aggregate(" new [] {", (x, y) => x + $"\"{y}\",");

        var modified = arr.Substring(0, arr.Length - 1) + "}";
        var originalNamesStr = originalNames.Substring(0, originalNames.Length - 1) + "}\n";
        var methodBody = $"""
                            respectAttribute 
                                    ? {modified}
                                    : {originalNamesStr};
                          """;
        return start + methodBody;
    }


    private static string GenerateConvertFromName(EnumDeclarationSyntax @enum)
    {
        var enumName = @enum.Identifier.ToString();
        var start = $"""
                         /// <summary>
                         /// It will try to convert the <paramref name="value"/> to <see cref="{enumName}"/>
                         /// </summary>
                         /// <param name="value" >The value that is being converted</param>
                         /// <param name="respectAttribute"> Flag specifying whether the attribute EnumName should be respected </param>
                         /// <exception cref="ArgumentOutOfRangeException">When <paramref name="value" /> cannot be matched </exception>
                         /// <returns> <see cref="{enumName}" /> </returns>
                         public static {enumName} TryConvertFromName(string value, bool respectAttribute = false)
                          =>
                     """;
        var body1 = @enum.Members
            .Select(x => (x.GetDesiredMemberName(x.Identifier.ValueText), $"{enumName}.{x.Identifier.ValueText}"))
            .Select(x => $"             \"{x.Item1}\" => {x.Item2},\n")
            .Aggregate(" value switch \n        {\n ", (x, y) => x + $"{y}");

        var body2 = @enum.Members
            .Select(x => (x.Identifier.ValueText, $"{enumName}.{x.Identifier.ValueText}"))
            .Select(x => $"             \"{x.Item1}\" => {x.Item2},\n")
            .Aggregate(" value switch \n       {\n ", (x, y) => x + $"{y}");

        var end = """
                                _ => throw new ArgumentOutOfRangeException()
                         }
                  """;
        return
            $"""
             {start} respectAttribute
                 ? {body1}{end}
                 : {body2}{end};
             """;
    }


    private static string GenerateGetMaxValue(EnumDeclarationSyntax @enum, Compilation compilation)
    {
        var enumName = @enum.Identifier.ToString();
        var enumSymbol = @enum.GetBaseType();
        var fieldSymbols = @enum.Members
            .Select(x => compilation.GetSemanticModel(x.SyntaxTree).GetDeclaredSymbol(x))
            .OfType<IFieldSymbol>()
            .Select(x => x.ConstantValue)
            .OrderByDescending(x => x)
            .ToArray();
        return $"""
                    /// <summary>
                    /// It will return the biggest value from <see cref="{enumName}" /> as <c>{enumSymbol}</c>
                    /// </summary>
                    public static {enumSymbol} GetMaxValue() => ({enumSymbol}){fieldSymbols.FirstOrDefault() ?? 0};
                """;
    }

    private static string GenerateGetMinValue(EnumDeclarationSyntax @enum, Compilation compilation)
    {
        var enumName = @enum.Identifier.ToString();
        var enumSymbol = @enum.GetBaseType();
        var fieldSymbols = @enum.Members
            .Select(x => compilation.GetSemanticModel(x.SyntaxTree).GetDeclaredSymbol(x))
            .OfType<IFieldSymbol>()
            .Select(x => x.ConstantValue)
            .OrderBy(x => x)
            .ToArray();
        return $"""
                    /// <summary>
                    /// It will return the smallest value from <see cref="{enumName}" /> as <c>{enumSymbol}</c>
                    /// </summary>
                    public static {enumSymbol} GetMinValue() => ({enumSymbol}){fieldSymbols.FirstOrDefault() ?? 0};
                """;
    }

    private static string GenerateConvertFromValue(EnumDeclarationSyntax @enum, Compilation compilation)
    {
        var enumName = @enum.Identifier.ToString();
        var enumSymbol = @enum.GetBaseType();
        var fieldSymbols = @enum.Members
            .Select(x => compilation.GetSemanticModel(x.SyntaxTree).GetDeclaredSymbol(x))
            .OfType<IFieldSymbol>()
            .Select(x => $"\n               {x.ConstantValue} => {enumName}.{x.Name},")
            .Aggregate("", (x, y) => x + $"{y}");

        return $$"""
                      /// <summary>
                      /// It will try to return the correct <see cref="{{enumName}}" /> 
                      /// based on <paramref name="value" />
                      /// </summary>
                      /// <param name="value" >The value that is being converted</param>
                      /// <returns> <see cref="{{enumName}}" /> </returns>
                      /// <exception cref="ArgumentOutOfRangeException">When <paramref name="value" /> cannot be matched </exception>
                      public static {{enumName}} TryConvertFrom({{enumSymbol}} value)
                          => value switch 
                              {{{fieldSymbols}}
                                _ => throw new ArgumentOutOfRangeException()
                              };
                 """;
    }

    private static string GenerateAddFlag(EnumDeclarationSyntax enumDeclarationSyntax)
    {
        var enumName = enumDeclarationSyntax.Identifier.ToString();
        return $$"""
                 /// <summary>
                 /// It will add the <paramref name="other"/> flag to the <paramref name="source"/> 
                 /// </summary>
                 /// <param name="source">The enum on which the flag will be added</param>
                 /// <param name="other">The other flag value</param>
                 /// <returns>{{enumName}} with the added <paramref name="other" /> </returns>
                 public static {{enumName}} AddFlag(this {{enumName}} source, {{enumName}} other)
                 {
                    source |= other;
                    return source;
                 }
                 """;
    }


    private static string GenerateRemoveFlag(EnumDeclarationSyntax enumDeclarationSyntax)
    {
        var enumName = enumDeclarationSyntax.Identifier.ToString();
        return $$"""
                 /// <summary>
                 /// It will remove the <paramref name="other"/> flag from the <paramref name="source"/> 
                 /// </summary>
                 /// <param name="source">The enum from which the flag will be removed</param>
                 /// <param name="other">The other flag value</param>
                 /// <returns>{{enumName}} with the removed <paramref name="other" /> </returns>
                 public static {{enumName}} RemoveFlag(this {{enumName}} source, {{enumName}} other)
                 {
                    source &= ~other;
                    return source;
                 }
                 """;
    }


    private static string GenerateContainsFlag(EnumDeclarationSyntax enumDeclarationSyntax)
    {
        var enumName = enumDeclarationSyntax.Identifier.ToString();
        return $"""
                /// <summary>
                /// It will check if the <paramref name="other"/> contains <paramref name="source"/> 
                /// </summary>
                /// <param name="source">The enum which will be checked</param>
                /// <param name="other">The other flag value</param>
                /// <returns>
                /// <c>true</c> if <paramref name="source"/>  contains <paramref name="other"/> otherwise <c>false</c>
                /// </returns>
                public static bool ContainsFlag(this {enumName} source, {enumName} other)
                   => (source & other) != 0;
                """;
    }
}